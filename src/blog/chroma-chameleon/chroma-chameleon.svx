---
title: Chroma chameleon
description: Add life and the colors of the rainbow to an adorable lizard.
date: 2023-03-24 17:54:56
---

<script>
    import Center from '$lib/components/blog/Center.svelte';

	import Chroma from './Chroma.svelte'
	import Translate from './Translate.svelte'
	import Animate from './Animate.svelte'
	import svg from './svg.js'
</script>

Ask me to paint you a color-changing lizard and I would sketch you something like the following SVG.

<Center element="figure" maxInlineSize="28rem">
	{@html svg['chameleon']}
</Center>

Circles for the eye popping prominently on one end. `<path>` elements for the round-ish body and a pair of limbs on the other. The visual is already enough to convince you: before you sits a small, even adorable, chameleon.

It isn't doing a very good job in hiding, but this particular creature is a bit of a show-off. It doesn't mind being seen, and as a matter of fact, it delights in showing its full range of colors.

<Center element="figure" maxInlineSize="28rem">
	<Chroma />
</Center>

How? Always with SVG. Let me set up a canvas with one conspicuous rectangle and explain in detail.

```html	
<svg viewBox="0 0 100 100">
	<rect width="100" height="100" />
</svg>
```

## Colors

With the `fill` attribute you are able to paint the rectangle with a color. Any CSS-valid value will do.

```html
<rect fill="hsl(0, 0%, 30%)" width="100" height="100" />
```

We are not interested in a solid fill, however, and promptly, SVG offers the `<linearGradient>` element. Add an instance with a specific `id` and point to the gradient through the `fill` attribute.

```html
<linearGradient id="gradient">
	<!-- ... -->
</linearGradient>
<rect fill="url(#gradient)" width="100" height="100" />
```

Of course you need to build the gradient to actually color the shape. In between the opening and closing tags add a `<stop>` element.

```html
<linearGradient id="gradient">
	<stop stop-color="hsl(0, 85%, 72%)" offset="0" />
</linearGradient>
```

The name of the attributes makes the syntax rather clear: `stop-color` introduces the color, `offset` the point where the color should start. This last attribute falls in the 0 to 1 range, but you could use a percentage as well — 0.2 or 20%. Whichever version suits you best.

Small detail aside, to paint with the colors of the rainbow the <abbr title="Hue Saturation Lightness">HSL</abbr> format helps tremendously. Change the hue across the [0-360] spectrum and you eventually build a most colorful gradient. Red, yellow, green. You get the gist.

```html
<stop offset="0" stop-color="hsl(0, 85%, 72%)" />
<stop offset="0.2" stop-color="hsl(60, 85%, 72%)" />
<stop offset="0.4" stop-color="hsl(120, 85%, 72%)" />
<stop offset="0.6" stop-color="hsl(180, 85%, 72%)" />
<stop offset="0.8" stop-color="hsl(240, 85%, 72%)" />
<stop offset="1" stop-color="hsl(300, 85%, 72%)" />
```

And you eventually find a most stylish rectangle.

<Center element="figure" maxInlineSize="22rem">
	{@html svg['linear-gradient']}
</Center>

## Rainbows

One rainbow is striking already, but we can do better. Ultimately we want to animate the shape to move horizontally, in a seemingly endless stream of colors. To achieve this feat SVG has a few tricks, but mainly attributes, up its sleeve.

Go back to the linear gradient. Past the `id` attribute we can specify the coordinates for the gradient itself.

<!-- prettier-ignore -->
```html
<linearGradient 
	id="gradient" 
	x1="0" 
	x2="1" 
	y1="0" 
	y2="0">
	<!-- ...stops -->
</linearGradient>
```

From 0 to 1 the values instruct the gradient to go from left to right. Have the second point end earlier, at 0.5, and the gradient stops midway through.

<Center element="figure" maxInlineSize="22rem">
	{@html svg['x-coordinates']}
</Center>

Set the `spreadMethod` attribute to `reflect`.

<!-- prettier-ignore -->
```html
<linearGradient 
	id="gradient" 
	spreadMethod="reflect"
	x1="0" 
	x2="0.5" 
	y1="0" 
	y2="0" >
	<!-- ...stops -->
</linearGradient>
```

And instead of completing the rectangle with the final stop the second half mirrors the first. Purple, back to blue, green and eventually the original red.

<Center element="figure" maxInlineSize="22rem">
	{@html svg['spread-method']}
</Center>

The result is charming, but you might anticipate just how essential the change is for our translating needs. Add a rectangle to the left.

```html
<rect fill="url(#gradient)" width="100" height="100" />
<rect fill="url(#gradient)" x="-100" width="100" height="100" />
```

The shape has the same size, the same gradient — it's essentially a copy waiting patiently outside of the visible area.

Add a group around both shapes.

```html
<g>
	<!-- ...rects -->
</g>
```

In the moment you translate the node you are re-introduced to the colors. From left to right.

<Center maxInlineSize="22rem">
	<Translate />
</Center>

Animate the change with CSS and voilà. The effect is complete.

<Center maxInlineSize="22rem">
	<Animate />
</Center>

The animation itself is endless, moving the two rectangles to the right before resuming the original coordinate.

```css
g {
	animation: translate 5s infinite;
}

@keyframes translate {
	to {
		transform: translate(100px, 0);
	}
}
```

But since the gradient begins exactly as it ends, the jump is imperceptible.

One more detail works to sell the illusion: the timing function. By default animations slow down to reach the final value, but in our project, there is no such thing. You might know of the two rectangles, but to the untrained eye the rainbow continues indefinitely. In light of this, have the animation move linearly.

```css
g {
	animation: translate 5s linear infinite;
}
```

The gradient begins as it ends, and so should the movement.

## Clip

Colored, animated. The canvas resembles the chromatic lizard more and more. But there are no rectangles in the original picture, are there? Well, in fact, there are two of them, with the same gradient and the same horizontal translation.

I decided to animate the shapes only as the lizard appears on screen with JavaScript and the intersection observer API, but that's not the first thing to jump to your eyes.

You just see the outline of the lizard, not the regular polygons. 

SVG offers here the `clipPath>`element. Add one similarly to the linear gradient. 

```html
<clipPath id="clip">
<!-- ... -->
</clipPath>
```

And apply the clip to the rectangles with the `clip-path` attribute. 

```html
<g clip-path="url(#clip)">
<!-- ...rects -->
</g>
```

The shapes you add in the clip describe the visible area. Consider for instance a path element, fittingly drawing an arc. 

<Center element="figure" maxInlineSize="22rem">
	{@html svg['path']}
</Center

If you were to include the shape not in the SVG, after the rectangles, but in the clip instead. 

```
<clipPath id="clip">
 <path />
</clipPath>
```

The rainbow is clipped in a familiar manner. 

<Center element="figure" maxInlineSize="22rem">
	{@html svg['clip-path']}
</Center>

This is exactly what happens with the lizard. Instead of one arc, however, the clip includes the head and the body of the now more secretive creature.