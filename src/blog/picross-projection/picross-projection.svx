---
title: Picross projection
description: Adding perspective to otherwise 2D pictures
date: 2023-02-22T21:29:02
---

<script>
    import Center from '$lib/components/blog/Center.svelte'

	import svg from './svg.js'
	import Level from './Level.svelte'
	import Puzzle from './Puzzle.svelte'
</script>

{@html svg['defs']}

With [Picross 2D](/picross-2d) we visualized solved nonogram puzzles with a grid. Columns and rows peppered with rectangles to create rudimentary, but rather believable, paintings in two dimensions. With a bit of ingenuity, experimentation and a good dose of patience, it is possible to extend the two-dimensional picture and create the illusion of depth. Only with SVG.

## Cube

The key of this article is a `<path>` element tracing the contours of a cube.

```html
<svg viewBox="0 0 1 1">
	<path fill="currentColor" d="M 0 0.25 l 0.5 -0.25 0.5 0.25 0 0.5 -0.5 0.25 -0.5 -0.25" />
</svg>
```

We create the element to fit in a rectangle 1 unit wide, 1 unit tall. Conceptually, this matches the size of a single cell in the previous 2D grid.

<Center maxInlineSize="18rem">
    {@html svg['cube']}
</Center>

To further the sense of depth, add shadows in the form of black, translucent faces.

```html
<g fill="black">
	<path opacity="0.5" d="M 0 0.25 l 0.5 0.25 0 0.5 -0.5 -0.25" />
	<path opacity="0.25" d="M 0.5 0.5 l 0.5 -0.25 0 0.5 -0.5 0.25" />
</g>
```

Added on top of the first shape, the two emulate a light source from north-east. Something which becomes the more evident the lighter the color.

<Center maxInlineSize="24rem">
    {@html svg['shadow']}
</Center>

Turns out, that's all you need in terms of drawing. Just the cube, repeated similarly to the rectangles in the previous effort.

Define the shape in a helpful `<defs>` block.

```html
<defs>
	<g id="cube">
		<!-- paths -->
	</g>
</defs>
```

And you'll be able to add the fancy shape in the SVG document through the `<use>` element.

```html
<g fill="currentColor">
	<use href="#cube" />
</g>
```

## Coordinates

A small recap for the two-dimensional project.

Based on a string of characters, separating the rows with new line characters and highlighting filled squares with `o`s characters.

```js
const level = `xxxoo
xxxox
xxxox
xxoox
oooox
oooox
oxxox
oxxox`;
```

We created `grid` to encapsulate the letters in a 2D array.

```js
const grid = level.split('\n').map((row) => row.split(''));
```

This collection gave us the width and height of the canvas.

```js
const height = grid.length;
const width = grid[0].length;
```

And ultimately the coordinates of the round character in a one-dimensional array â€” `coordinates`. I'll refer you [to the article](/picross-2d#coordinates) once more to find the logic for the (x, y) values, but based on this structure we finally drew the level with rectangles.

```svelte
{#each coordinates as { x, y }}
	<rect {x} {y} width="1" height="1" />
{/each}
```

Let's try and replace the `<rect>` element with our custom cube.

```diff
-<rect {x} {y} width="1" height="1" />
+<use {x} {y} href="#cube" />
```

<Level />

And let's call this a solid starting point.

## Projection

We need to position the elements in the perspective afforded by the cube, into the context of an _isometric_ projection.

To understand how consider the following grid as a reference, beyond a nice pattern for bathroom tiles.

<Center maxInlineSize="28rem">
    {@html svg['isometric-grid']}
</Center>

The moment you have a row of neighboring cubes. You realize the excessive horizontal whitespace.. I expanded the canvas to avoid one annoying mishap: use the width and height from the previous version.

<Level padding={0} />

```html
<use x="0" y="0" href="#cube" />
<use x="1" y="0" href="#cube" />
<use x="2" y="0" href="#cube" />
```

<Center maxInlineSize="24rem">
    {@html svg['cubes']}
</Center>

We want to position the elements at increments of half the width: 0.5, 1, 1.5 and so forth.

```html
<use x="0" y="0" href="#cube" />
<use x="0.5" y="0" href="#cube" />
<use x="1" y="0" href="#cube" />
```

<Center maxInlineSize="24rem">
    {@html svg['offset-x']}
</Center>

In terms of SVG, later shapes are drawn above previous ones, meaning you need to reverse the order.

```html
<use x="1" y="0" href="#cube" />
<use x="0.5" y="0" href="#cube" />
<use x="0" y="0" href="#cube" />
```

But halving the offset is enough to realize the tight fit.

<Center maxInlineSize="24rem">
    {@html svg['reverse']}
</Center>

Vertically, we want to lift up each successive tile with a consistent ascension.

```html
<use x="1" y="-0.5" href="#cube" />
<use x="0.5" y="-0.25" href="#cube" />
<use x="0" y="0" href="#cube" />
```

Each column is raised by half the horizontal offset: 0.25, 0.5 and so on.

<Center maxInlineSize="24rem">
    {@html svg['offsets-y']}
</Center>

Enough to complete a row. Say you have additional rows, however.

```html
<use x="0" y="1" href="#cube" />
<use x="0" y="2" href="#cube" />
<!-- ...use -->
```

And once again the unitary increment proves to be excessive.

<Center maxInlineSize="24rem">
    {@html svg['rows']}
</Center>

Place the elements at increments of half the height.

```html
<use x="0" y="1" href="#cube" />
<use x="0" y="0.5" href="#cube" />
<!-- ...use -->
```

And the graphical projection is complete.

<Center maxInlineSize="24rem">
    {@html svg['offsets']}
</Center>

Notice again the order. You start from the bottom-most element to draw the preceding rows effectively on top.

## Level

Let's dive back into the more elaborate grid proposed by the string of characters.

Instead of using the index for the coordinates.

```js
for (let y = 0; y < grid.length; y++) {
	for (let x = 0; x < grid[0].length; x++) {
		coordinates.push({ x, y });
	}
}
```

Rename the variables to generic counter names.

```js
for (let i = 0; i < grid.length; i++) {
	for (let j = 0; j < grid[0].length; j++) {
		//
	}
}
```

As per the smaller example, compute the two now-offset, values for the coordinates.

```js
const x = j / 2;
const y = i / 2 - x / 2;

coordinates.push({ x, y });
```

<Center maxInlineSize="28rem">
    <Level offset={true} />
</Center>

Impressed, but not completely? You certainly remember the note about the source order. Reverse the order of the final array.

```js
coordinates.reverse();
```

And the puzzle assumes its rightful, three dimensional shape.

<Center maxInlineSize="28rem">
    <Level offset={true} reverse={true} />
</Center>

The `reverse` method modifies the original data structure. If you don't fancy the feature, you might prefer creating a separate collection.

```js
const drawCoordinates = [...coordinates].reverse();
```

Or again reverse the shallow copy as you draw the elements.

```svelte
{#each [...coordinates].reverse() as { x, y }}
	<use {x} {y} href="#cube" />
{/each}
```

Whichever way suits your coding style best.

## Canvas

Most assuredly, it did not escape your eyes that the visual is off center.

I expanded the canvas to avoid one annoying mishap: use the width and height from the 2D grid and, perhaps expectedly, the values do not fit the composition.

<Center maxInlineSize="28rem">
    <Level offset={true} reverse={true} padding={0} />
</Center>

There is certainly a way to find the numbers in terms of the projection, but ultimately, I decided to find a workaround with JavaScript instead.

`coordinates` describes the position of the cubes. What is the width of the canvas? That would be the greatest `x` value _plus_ 1. 1 for the size of the cube itself.

What is the height? The logic is similar, but not the same. As you lift the cubes up, some of them assume a negative offset.

The height is therefore the sum of these two values. Plust 1. Always plus 1 to account for that very last `<use />` element.

Shift the entire puzzle down to avoid cropping. And finally, you complete the picture.

<Center maxInlineSize="28rem">
    <Puzzle />
</Center>

Hope you don't mind if I pick this occasion to add color and a small showcase.

<Center maxInlineSize="28rem">
    <Puzzle key="clover" />
</Center>

<Center maxInlineSize="28rem">
    <Puzzle key="apple" />
</Center>

<Center maxInlineSize="28rem">
    <Puzzle key="sea-horse" />
</Center>

<Center maxInlineSize="28rem">
    <Puzzle key="butterfly" />
</Center>
