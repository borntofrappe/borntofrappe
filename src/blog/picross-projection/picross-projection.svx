---
title: Picross projection
description: Adding perspective to otherwise 2D pictures
date: 2023-02-22T21:29:02
---

<script>
	import svg from './svg.js'
	import Level from './Level.svelte'
</script>

{@html svg['defs']}

With [Picross 2D](/picross-2d) we visualized solved nonogram puzzles with a grid. Columns and rows peppered with rectangles to create rudimentary, but rather believable, paintings in two dimensions. With a bit of ingenuity, experimentation and a good dose of patience, it is possible to extend the two-dimensional picture and create the illusion of depth. Only with SVG.

## Cube

The key of this article is a `<path>` element tracing the contours of a cube.

```html
<svg viewBox="0 0 1 1">
	<path fill="currentColor" d="M 0 0.25 l 0.5 -0.25 0.5 0.25 0 0.5 -0.5 0.25 -0.5 -0.25" />
</svg>
```

We create the element to fit in a rectangle 1 unit wide, 1 unit tall. Conceptually, this matches the size of a single cell in the previous 2D grid.

{@html svg['cube']}

To further the sense of depth, add shadows in the form of black, translucent faces.

```html
<g fill="black">
	<path opacity="0.5" d="M 0 0.25 l 0.5 0.25 0 0.5 -0.5 -0.25" />
	<path opacity="0.25" d="M 0.5 0.5 l 0.5 -0.25 0 0.5 -0.5 0.25" />
</g>
```

Added on top of the first shape, the two emulate a light source from north-east. Something which becomes the more evident the lighter the color.

{@html svg['shadow']}

Turns out, that's all you need in terms of drawing. Just the cube, repeated similarly to the rectangles in the previous effort.

Define the shape in a helpful `<defs>` block.

```html
<defs>
	<g id="cube">
		<!-- paths -->
	</g>
</defs>
```

And you'll be able to add the fancy shape in the SVG document through the `<use>` element.

```html
<g fill="currentColor">
	<use href="#cube" />
</g>
```

## Coordinates

A small recap for the two-dimensional project.

Based on a string of characters, separating the rows with new line characters and highlighting filled squares with `o`s characters.

```js
const level = `xxxoo
xxxox
xxxox
xxoox
oooox
oooox
oxxox
oxxox`;
```

We created `grid` to encapsulate the letters in a 2D array.

```js
const grid = level.split('\n').map((row) => row.split(''));
```

This collection gave us the width and height of the canvas.

```js
const height = grid.length;
const width = grid[0].length;
```

And ultimately the coordinates of the round character in a one-dimensional array â€” `coordinates`. I'll refer you [to the article](/picross-2d#coordinates) once more to find the logic for the (x, y) values, but based on this structure we finally drew the level with rectangles.

```svelte
{#each coordinates as { x, y }}
	<rect {x} {y} width="1" height="1" />
{/each}
```

Let's try and replace the `<rect>` element with our custom cube.

```diff
-<rect {x} {y} width="1" height="1" />
+<use {x} {y} href="#cube" />
```

<Level />

And let's call this a solid starting point.

## Projection

We need to position the elements in the perspective afforded by the cube, into the context of an _isometric_ projection.

To understand how consider the following grid as a reference, beyond a nice pattern for bathroom tiles.

{@html svg['isometric-grid']}

The moment you have a row of neighboring cubes. You realize the excessive horizontal whitespace.

```html
<use x="0" y="0" href="#cube" />
<use x="1" y="0" href="#cube" />
<use x="2" y="0" href="#cube" />
```

{@html svg['cubes']}

We want to position the elements at increments of half the width: 0.5, 1, 1.5 and so forth.

```html
<use x="0" y="0" href="#cube" />
<use x="0.5" y="0" href="#cube" />
<use x="1" y="0" href="#cube" />
```

{@html svg['offset-x']}

In terms of SVG, later shapes are drawn above previous ones, meaning you need to reverse the order.

```html
<use x="1" y="0" href="#cube" />
<use x="0.5" y="0" href="#cube" />
<use x="0" y="0" href="#cube" />
```

But halving the offset is enough to realize the tight fit.

{@html svg['reverse']}

Vertically, we want to lift up each successive tile with a consistent ascension.

```html
<use x="1" y="-0.5" href="#cube" />
<use x="0.5" y="-0.25" href="#cube" />
<use x="0" y="0" href="#cube" />
```

Each column is raised by half the horizontal offset: 0.25, 0.5 and so on.

{@html svg['offsets-y']}

Enough to complete a row. Say you have additional rows, however.

```html
<use x="0" y="1" href="#cube" />
<use x="0" y="2" href="#cube" />
<!-- ...use -->
```

And once again the unitary increment proves to be excessive.

{@html svg['rows']}

Place the elements at increments of half the height.

```html
<use x="0" y="1" href="#cube" />
<use x="0" y="0.5" href="#cube" />
<!-- ...use -->
```

And the graphical projection is complete.

{@html svg['offsets']}

Notice again the order. You start from the bottom-most element to draw the preceding rows effectively on top.

## Level

Let's dive back into the more elaborate grid proposed by the string of characters.

Instead of using the index for the coordinates.

```js
for (let y = 0; y < grid.length; y++) {
	for (let x = 0; x < grid[0].length; x++) {
		coordinates.push({ x, y });
	}
}
```

Rename the variables to generic counter names.

```js
for (let i = 0; i < grid.length; i++) {
	for (let j = 0; j < grid[0].length; j++) {
		//
	}
}
```

As per the smaller example, compute the two now-offset, values for the coordinates.

```js
const x = j / 2;
const y = i / 2 - x / 2;

coordinates.push({ x, y });
```

<Level offset={true} />

Impressed, but not completely? You certainly remember the note about the source order. Reverse the order of the final array.

```js
coordinates.reverse();
```

And the puzzle assumes its rightful, three dimensional shape.

<Level offset={true} reverse={true} />

The `reverse` method modifies the original data structure. If you don't fancy the feature, you might prefer creating a separate collection.

```js
const drawCoordinates = [...coordinates].reverse();
```

Or again reverse the shallow copy as you draw the elements.

```svelte
{#each [...coordinates].reverse() as { x, y }}
	<use {x} {y} href="#cube" />
{/each}
```

Whichever way suits your coding style best.
