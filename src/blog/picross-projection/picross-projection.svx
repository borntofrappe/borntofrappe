---
title: Picross projection
description: Adding perspective to otherwise 2D pictures
date: 2023-02-22T21:29:02
---

<script>
    import Center from '$lib/components/blog/Center.svelte'

	import svg from './svg.js'
	import Coordinates from './Coordinates.svelte'
	import Level from './Level.svelte'
	import Showcase from './Showcase.svelte'
</script>

{@html svg['defs']}

With [Picross 2D](/picross-2d) we visualized solved nonogram puzzles with a grid. Columns and rows peppered with rectangles to create rudimentary, but rather believable, paintings in two dimensions. With a bit of ingenuity, experimentation and a good dose of patience, it is possible to extend the two-dimensional picture and create the illusion of depth. Only with SVG.

## Cube

The key to add perspective is a `<path>` element tracing the contours of a cube.

```html
<svg viewBox="0 0 1 1">
	<path fill="currentColor" d="M 0 0.25 l 0.5 -0.25 0.5 0.25 0 0.5 -0.5 0.25 -0.5 -0.25" />
</svg>
```

We create the element to fit in a rectangle 1 unit wide, 1 unit tall. Conceptually, this matches the size of a single cell in the previous 2D grid.

<Center maxInlineSize="18rem">
    {@html svg['cube']}
</Center>

To further the sense of depth, add shadows in the form of black, translucent faces.

```html
<g fill="black">
	<path opacity="0.5" d="M 0 0.25 l 0.5 0.25 0 0.5 -0.5 -0.25" />
	<path opacity="0.25" d="M 0.5 0.5 l 0.5 -0.25 0 0.5 -0.5 0.25" />
</g>
```

On top of the first shape, the two emulate a light source from north-east. Something which becomes the more evident the lighter the color.

<Center maxInlineSize="24rem">
    {@html svg['shadow']}
</Center>

And surprise surprise, that's all you need in terms of drawing. Just the cube, repeated similarly to the rectangles in the previous effort.

Define the shape in a helpful `<defs>` block.

```html
<defs>
	<g id="cube">
		<!-- paths -->
	</g>
</defs>
```

And you'll be able to add the fancy shape in the SVG document through the `<use>` element.

```html
<g fill="currentColor">
	<use href="#cube" />
</g>
```

## Coordinates

A small recap for the two-dimensional project.

Based on a string of characters, separating the rows with new line characters and highlighting filled squares with `o`s characters.

```js
const level = `xxxoo
xxxox
xxxox
xxoox
oooox
oooox
oxxox
oxxox`;
```

We created `grid` to isolate the letters in a 2D array.

```js
const grid = level.split('\n').map((row) => row.split(''));
```

This collection gave us the width and height of the canvas.

```js
const height = grid.length;
const width = grid[0].length;
```

And ultimately the coordinates of the round character in a one-dimensional array â€” `coordinates`. I'll refer you [to the article](/picross-2d#coordinates) once more to find the logic for the (x, y) values, but based on this structure we finally drew the level with rectangles.

```svelte
{#each coordinates as { x, y }}
	<rect {x} {y} width="1" height="1" />
{/each}
```

Let's try and replace the `<rect>` element with our custom cube.

```diff
-<rect {x} {y} width="1" height="1" />
+<use {x} {y} href="#cube" />
```

<Coordinates />

And let's call this a solid starting point.

## Projection

We need to position the elements in the perspective afforded by the cube, into the context of an _isometric_ projection.

To understand how, consider the following grid as a reference, beyond a stylish pattern for a modern living room.

<Center maxInlineSize="28rem">
    {@html svg['isometric-grid']}
</Center>

The moment you have a row of neighboring cubes.

```html
<use x="0" y="0" href="#cube" />
<use x="1" y="0" href="#cube" />
<use x="2" y="0" href="#cube" />
```

<Center maxInlineSize="24rem">
    {@html svg['cubes']}
</Center>

You want to position the elements at increments of half the width: 0.5, 1, 1.5 and so forth.

```html
<use x="0" y="0" href="#cube" />
<use x="0.5" y="0" href="#cube" />
<use x="1" y="0" href="#cube" />
```

<Center maxInlineSize="24rem">
    {@html svg['offset-x']}
</Center>

In terms of SVG, later shapes are drawn above previous ones, meaning you need to reverse the order.

```html
<use x="1" y="0" href="#cube" />
<use x="0.5" y="0" href="#cube" />
<use x="0" y="0" href="#cube" />
```

But halving the offset is enough to realize the tight fit.

<Center maxInlineSize="24rem">
    {@html svg['reverse']}
</Center>

Vertically, we want to lift up each successive tile to create a consistent ascension.

```html
<use x="1" y="-0.5" href="#cube" />
<use x="0.5" y="-0.25" href="#cube" />
<use x="0" y="0" href="#cube" />
```

Each column is raised by half the horizontal offset: 0.25, 0.5 and so on.

<Center maxInlineSize="24rem">
    {@html svg['offsets-y']}
</Center>

Enough to complete a row. Say you have additional rows, however.

```html
<use x="0" y="1" href="#cube" />
<use x="0" y="2" href="#cube" />
<!-- ...use -->
```

And once again the unitary increment proves to be excessive.

<Center maxInlineSize="24rem">
    {@html svg['rows']}
</Center>

Place the elements at increments of half the height.

```html
<use x="0" y="1" href="#cube" />
<use x="0" y="0.5" href="#cube" />
<!-- ...use -->
```

And the graphical projection is complete.

<Center maxInlineSize="24rem">
    {@html svg['offsets']}
</Center>

Notice again the order. You start from the bottom-most element to draw the preceding rows effectively on top.

## Level

Let's dive back into the more elaborate grid proposed by the string of characters and adapt the position per the projection.

Instead of using the index for the coordinates.

```js
for (let y = 0; y < grid.length; y++) {
	for (let x = 0; x < grid[0].length; x++) {
		coordinates.push({ x, y });
	}
}
```

Rename the variables to generic counter labels.

```js
for (let i = 0; i < grid.length; i++) {
	for (let j = 0; j < grid[0].length; j++) {
		//
	}
}
```

As per the smaller example, compute the two now-offset, values for the coordinates. X equal to half the index, y equal to half its own index detracted by half the horizontal offset.

```js
const x = j / 2;
const y = i / 2 - x / 2;

coordinates.push({ x, y });
```

<Center maxInlineSize="28rem">
    <Coordinates offset={true} />
</Center>

Impressed, but not completely? You certainly remember the note about the source order. Reverse the order of the final array.

```js
coordinates.reverse();
```

And the puzzle assumes its rightful, three dimensional shape.

<Center maxInlineSize="28rem">
    <Coordinates offset={true} reverse={true} />
</Center>

The `reverse` method technically modifies the original data structure, and if you don't fancy the feature, you might prefer creating a separate collection.

```js
const drawCoordinates = [...coordinates].reverse();
```

Or again reverse the shallow copy as you draw the elements.

```svelte
{#each [...coordinates].reverse() as { x, y }}
	<use {x} {y} href="#cube" />
{/each}
```

Whichever way suits your coding style best.

## Canvas

Most assuredly, it did not escape your eyes that the visual is off center, swarmed by a sea of unnecessary white-space.

I expanded the canvas to avoid one annoying mishap: use the width and height from the 2D grid and, perhaps expectedly, the values do not fit the composition.

<Center maxInlineSize="28rem">
    <Coordinates offset={true} reverse={true} padding={0} />
</Center>

There is certainly a way to find the numbers in terms of the projection, but ultimately, I decided to find a workaround with JavaScript instead.

`coordinates` describes the position of the cubes. Consider the x and y values in two sorted arrays.

What is the width, what is the height of the canvas? That would be the space between the first and last cube.

Horizontally and vertically.

Plus 1.Plus 1 to account for the size of the cube itself. You can't very well forget the last column, the last row.

Update the canvas with the new dimensions.

Finally, translate the picture per the initial, smallest coordinate.

The horizontal coordinate begins at 0,so the instruction is here superfluous, but the vertical values do become smaller -- consider how the cells are projected upwards. This last instruction moves the visual down, perfectly encapsulating the multi-dimensional level.

If you want to rely on the powerful viewBox attribute only you might translate the origin of the entire coordinate system.

But that's the last piece of SVG I will propose for the time being.

It wouldn't be fair to end on this note, however. After all, the 2d article proposed a handful of levels more. Let me offer them back, with a touch of color and a brand new perspective.

<Showcase />
