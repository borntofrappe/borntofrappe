---
title: String art
description: Draw SVG in a code editor, by hand and with the assistance of JavaScript.
date: 2023-08-29T09:35:16
---

<script>
	import Center from '$lib/components/blog/Center.svelte';

	import svg from './svg.js';
	import PointsAndPaths from './PointsAndPaths.svelte';
</script>

<Center element="figure" maxInlineSize="10rem">
	{@html svg['fox']}
</Center>

Writing SVG syntax _"by hand"_, directly in a code editor, takes a lot of patience.

```html
<svg viewBox="-50 -50 100 100">
	<!-- ... -->
</svg>
```

You have full control over the appearance of the graphic, but it's up to you to fill the canvas with elements and attributes, one line after the other.

Given enough time you may forgive the task, but if your intention is to show the result on the web, there are ways to ease the feat. With JavaScript specifically, you gain access to a host of methods, helping you compose the graphic and even create intriguing designs.

Consider a basic shape in the form of a `<circle>`.

```html
<circle fill="none" stroke="currentColor" r="40" />
```

With a stroke, without a fill, the code leads to a predictable, round outline. If you wanted, you could add more elements inside the shape, but what if you needed to draw points, or even lines, precisely on the contour of the circle? You can almost appreciate the idea already. A cross-stitch work of art, a web of interconnected lines threading the surface in any direction.

With the option of JavaScript, you can achieve the feat with one method: `getPointAtLength`.

```js
const element = document.querySelector('circle');
element.getPointAtLength(0); // SVGPoint {x: 40, y: 0}
```

The function takes a number, an offset, and returns an _SVG point_. Behind the fancy label, however, there's just an object with two properties, `x` and `y`.

And the function is close to everything you need to complete the design. What is left is a process, a way to repeat the instruction a number of times _and_ in the span of the circle, from start to end. Indeed, as the function takes a length, you may want to limit yourself to the perimeter. And for this, JavaScript helps you once more with a useful getter: `getTotalLength`.

```js
const length = element.getTotalLength();
```

Armed with the number, you can set up a regular for loop.

```js
const n = 5;
for (let i = 0; i < n; i++) {
	// ...
}
```

Iterating as many times as you want points, you are then able to find the coordinates at the proper increments.

```js
const offset = (length / n) * i;
const { x, y } = element.getPointsAtLength(offset);
```

You can store the information in an array, and use the data to draw points with `<circle>` elements.

```js
points.push({ x, y });
```

To draw lines, however, you need to go further. And you need further loops.

One loop to consider the points, from first to penultimate.

```js
for (let i = 0; i < points.length - 1; i++) {
	const { x: x1, y: y1 } = points[i];
	// ...
}
```

An additional, nested loop, from the point next to the current one to the very last.

```js
// ...
for (let j = i + 1; j < points.length; j++) {
	const { x: x2, y: y2 } = points[j];
}
```

Looping _"forwards"_, in this manner, you consider lines in one direction only, but it's more than enough to complete the set. It is rather wasteful to trace your way backwards after all.

Again you can store the data in an array, and there are several ways you can save the points. If you want to draw lines with a line element, this one requires four attributes, from the start and end coordinates.

```html
<line x1="40" y1="0" x2="12.319074630737305" y2="38.055755615234375" />
```

In this instance you can store the points with plain objects, with four matching properties.

```js
lines.push({ x1, y1, x2, y2 });
```

If you want to draw the segments with a path element instead, this one looks for a string in the d attribute.

```html
<path d="M 40 0 12.319074630737305 38.055755615234375" />
```

Following the _"M"_ character the string works from one set of coordinates to the other, so that you can keep an array of instructions, an array of strings instead.

```js
lines.push(`M ${x1} ${y1} ${x2} ${y2}`);
```

And if you appreciate brevity, you might enjoy knowing that you don't need an array at all. In the `d` attribute, the instructions can very well follow each other. String after string.

```html
<path
	d="M 40 0 12.319074630737305 38.055755615234375M M 40 0 -32.3667755126953 23.503015518188477 ..."
/>
```

In light of this, you can add the instruction to a single string.

```js
lines += `M ${x1} ${y1} ${x2} ${y2}`;
```

With `<line>`s, with `<path>`s, with one single `<path>`, you have ways to mark the document and fill the circle. You can entertain the idea with a small playground.

<Center maxInlineSize="36rem">
	<PointsAndPaths />
</Center>

And you can definitely put the concept to the test to find the quaint vector graphic of your dreams.

<Center element="figure" maxInlineSize="20rem">
	{@html svg['dream-catcher']}
</Center>
