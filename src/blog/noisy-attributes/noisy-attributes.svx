---
title: Noisy attributes
description: SVG makes it easy to entertain and understand even the more obscure syntax.
date: 2023-08-21T17:35:14
---

<script>
	import Center from '$lib/components/blog/Center.svelte';

	import svg from './svg.js';
</script>

SVG shines in being able to match code to immediate results.

```html
<rect width="100" height="100" />
```

You are able to decipher most attributes by name, but even when the labels are more cryptic, you can appreciate their purpose just by changing the values. In this regard there's no better example than [SVG filters](/filter-art), and the many primitives baked in the framework.

Consider `feTurbulence`. The element promises to create a texture with a Person noise function and at two essential arguments: `numOctaves` and `baseFrequency`.

```html
<feTurbulence numOctaves="1" baseFrequency="0.1" />
```

But what do these attributes actually mean? One way to answer this question is plainly by trial. Different filters with different values.

<Center element="figure" maxInlineSize="36rem">
	{@html svg['feTurbulence']}
</Center>

Increase `numOctaves` and the texture becomes more complex. You can still see the pattern of the first picture, but the result is more varied.

Increase `baseFrequency` and the effect is quite different. The texture becomes almost unrecognizable, fragmented in smaller and smaller pieces.

With this in mind, you understand the influence of the attributes and you can continue to put the primitive to use â€” SGV for art.

That being said, there's certainly more behind the scenes. And once you research the topic a tad further, SVG helps once more to put words into pictures.

To understand how a noise function operates consider a 2D plane. On the y axis you chart the amplitude, a value describing the scale of the point. On the x axis you map the frequency, and separate the points in regular increments.

<Center element="figure" maxInlineSize="24rem">
	{@html svg['amplitude-frequency']}
</Center>

Connect the points and you find an _octave_. You can link the x, y coordinates any which way, even with straight lines, but to produce smoother changes a curve works best.

<Center element="figure" maxInlineSize="24rem">
	{@html svg['octave']}
</Center>

As you traverse the function the amplitude changes at random, per the random points, but smoothly, per the connection. You move in softer inclines rather than janky, immediate jumps.

Already you understand more about the filter primitive. `baseFrequency` describes the number of points in the octave function. As you increase the value, you need to connect the points in ever smaller curves. The randomness becomes more evident and the texture less predictable.

`numOctaves`? You are not limited to a single, interpolating curve. The moment you increase the counter, you repeat the exercise from the first function. You repeat the exercise of amplitude and frequency with one precaution: with each successive octave decrease the scale; with each successive octave increase the points.

You have a series of curves which are more and more variable, with smaller and smaller values. Add up the values to the first octave and the effect is complete.

<Center element="figure" maxInlineSize="44rem">
	{@html svg['octaves']}
</Center>

As the first function absorbs the changes the soft curve is augmented with small bumps, minor wrinkles.

`feTurbulence` works in one more dimension, mapping values on the x and y axis, but in exactly the same way. You proved this by changing the attributes, and you understand it by plotting a few values. More than enough to take the element and put the attributes to use. And possibly reveal a new image.

<Center element="figure" maxInlineSize="24rem">
	{@html svg['card-5']}
</Center>
