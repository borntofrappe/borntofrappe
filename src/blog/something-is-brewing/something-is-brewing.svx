---
title: Something is brewing
description: Draw and animate vector graphics to create a charming loader.
date: 2023-03-10 10:54:48
---

<script>
    import Center from '$lib/components/blog/Center.svelte';

    import svg from './svg.js';
    import Scene from './Scene.svelte';
</script>

The problem: you need a visual to pair the assuredly brief, but inevitable delay a page needs to load.

The tagline: SVG and CSS to the rescue.

## SVG syntax

The page in question offers a series of recipes, factual or otherwise, so it is only natural to conjure up SVG elements to draw a piece of kitchenware.

### Pot

A few elements allow to draw a convincing cauldron with just a few instructions. First a rounded rectangle for the edge.

```html
<g fill="#2e2e2c">
	<rect x="-20" width="40" height="8" rx="4" />
</g>
```

Having the `rx` attribute exactly as half the smaller size, as half the height, means the ends are perfectly round. Past the rectangle, a path crafting the rotund container with an overblown arc.

```html
<g fill="#2e2e2c">
	<!-- ... -->
	<path d="M -16 4 a 22 22 0 1 0 32 0" />
</g>
```

Finally, two rounded lines protruding from either end to support the piece.

```html
<g fill="none" stroke="#2e2e2c" stroke-width="6" stroke-linecap="round">
	<path d="M -5 20 l -10 20" />
	<path d="M 5 20 l 10 20" />
</g>
```

With the same color in the `fill` and `stroke` attributes the elements coalesce in the solid recipient.

<Center element="figure" maxInlineSize="28rem">
    {@html svg['cauldron']}
</Center>

### Flames

The `<path>` element is once more equipped for the heat source. A couple of bezier curves, pointing upwards, work to create a single candle-like flame.

```html
<path fill="#f04545" d="M 0 0 c -3.5 0 -4.5 -4.5 0 -6.5 4.5 1.5 3.5 6.5 0 6.5" />
```

To detail the visual we want to add another, smaller shape right on top. Another set of curves shining brightly in the heart of the larger whole. Here you can pick and choose a `d` attribute with smaller values. Or, use the very same string and scale the result down.

```html
<!-- ...path -->
<path
	transform="scale(0.5)"
	fill="#e8da38"
	d="M 0 0 c -3.5 0 -4.5 -4.5 0 -6.5 4.5 1.5 3.5 6.5 0 6.5"
/>
```

As you draw the shape from the bottom, the scaling operation has the second path reduce itself from the low origin.

Add a soft stroke around both shapes.

```html
<g stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	<!-- ...paths -->
</g>
```

And making sure to use the same color as the `fill` attribute, the sparkle is lit and alight.

<Center element="figure" maxInlineSize="28rem">
    {@html svg['flame']}
</Center>

No matter how beautiful, a solitary flame is not enogh for our cooking needs, though. You can actually give an `id` attribute to the shape and repeat it right afterwards, but for the sake of clarity, define a group in a <defs> element.

```html
<defs>
	<g id="flame">
		<!-- ...paths -->
	</g>
</defs>
```

To show the single flame back refer to the identifier through the `<use>` element. To complete the set repeat the instructions with different horizontal offsets.

The order here matters. To have the outer shapes behind include the copies _before_ the flames in the middle.

```html
<use transform="translate(8 0)" href="#flame" />
<use transform="translate(-8 0)" href="#flame" />
<use transform="translate(4 0)" href="#flame" />
<use transform="translate(-4 0)" href="#flame" />
<use href="#flame" />
```

SVG transformations help tremendously. Not only you are able to place the flames wherever needed. Through the rotate function you can spread the fire outwards.

```html
<use transform="translate(8 0) rotate(28)" href="#flame" />
<use transform="translate(-8 0) rotate(-28)" href="#flame" />
<!-- ... -->
```

And with the now-familiar scale keyword you can even reduce the size as you move away from the center.

```html
<use transform="translate(8 0) rotate(28) scale(0.8)" href="#flame" />
<!-- ... -->
```

How much to angle, how much to scale down each additional pair is a matter of taste, and one of the most entertaining parts of writing SVG in a code editor. Experiment with different values until you find a heart-warming visual.

<Center element="figure" maxInlineSize="28rem">
    {@html svg['flames']}
</Center>

### Goo

It doesn't take much to embellish the visual. Consider the simple cauldron, for instance. Add colorful lines on the right end â€” these are `<path>` elements with a noticeable, yellow-ish stroke

And the concoction becomes much more believable.

<Center element="figure" maxInlineSize="28rem">
    {@html svg['goo']}
</Center>

You can't see inside, but you can almost believe the exquisite elixir is going to reach the surface and escape the setting. Especially with such kindling.

### Bubbles

Let's exaggerate further. Reaching the boiling point it is only natural to spot a few bubbles, and a perfect opportunity to rehearse the workflow of the flames. One circle element works as a base.

```html
<circle r="4" fill="#f6c159" />
```

A smaller, lighter circle slightly off center gives the illusion of a light source.

<!-- prettier-ignore -->
```html
<circle r="4" fill="#f6c159" />
<circle r="1.5" cx="1" cy="-1" fill="#f1daae" />
```

As with the flames we enjoy more than one copy, so you might be familiar with the sequence. One definition.

```html
<defs>
	<g id="bubble">
		<!-- ...circles -->
	</g>
</defs>
```

Multiple use elements.

```html
<use transform="translate(10 -16)" href="#bubble" />
<use transform="translate(-2 -10) scale(0.8)" href="#bubble" />
<use transform="translate(-12 -20) scale(0.6)" href="#bubble" />
```

Positioned and scaled to your heart's content.

<Center element="figure" maxInlineSize="28rem">
    {@html svg['bubbles']}
</Center>

### Spoon

One last detail before we dive in the entertaining realm of cascading stylesheets. Add a line just behind the cauldron.

<Center element="figure" maxInlineSize="28rem">
    {@html svg['scene']}
</Center>

And the scene is set. After all, it would be irresponsible to leave the preparation unattended.

## CSS properties

As in the kitchen, it is helpful to have a plan. The goal here is to update the visual in a few ways, but always through the `transform` attribute. Or, to be technical, through the `transform` property.

```css
.element {
	transform: scale(1.25);
}
```

In the stylesheet, thanks to the concept of specificity, the transformation takes precedence on whichever value is set in the markup.

Back to the plan. It would be most charming to have the flames grow in size and perhaps even flicker. On top of this animation we can then treat ourself. Thicker gooey lines, bubbles actually floating, the spoon helpfully stirring the mixture.

### Flicker

To scale the flames you could update the `<use>` elements. Add a class on the instances.

```html
<use class="flicker" href="#flames" />
```

Resize the copy with the appropriate function.

```css
.flicker {
	transform: scale(0.7);
}
```

This works swimmingly for the central flame, but for the neighboring copies you would need to meddle with the SVG syntax to update the origin point, the point from where the animation takes place.

```html
<g transform="translate(8 0) rotate(28) scale(0.8)">
	<use class="flicker" href="#flames" />
</g>
```

I'll refer you to [a previous article](/svg-transform) for a more detailed explanation of the concept. In essence, you would need to apply a transformation beforehand, so that you scale the flame as you resized the first `<path>` to draw the brighter body, from the bottom. That being said, and at least for the current current project, there is a better way. Add the class _on the definition_ itself.

```html
<defs>
	<g class="flicker" id="flame">
		<!-- ...paths -->
	</g>
</defs>
```

If you are satisfied changing every instance in the same manner, you can then move on to the actual animation.

Easing functions, durations. Even the structure of the keyframes is ground for exploration. For the possibly simplest change restore the size to the original measure.

```css
.flicker {
	transform: scale(0.7);
	animation: flicker 6s;
}

@keyframes flicker {
	50% {
		transform: scale(1);
	}
}
```

A subtle effect with hopefully grander consequences.

<Center element="figure" maxInlineSize="30rem">
    <Scene animations={['flicker']} transition={false} />
</Center>
