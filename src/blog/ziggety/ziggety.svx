---
title: Ziggety
description: Animate 2D shapes with CSS. Animate pseudo-3D shapes with JavaScript and CSS still.
date: 2023-07-28T14:40:55
---

<script>
	import Center from '$lib/components/blog/Center.svelte';

	import svg from './svg.js';
	import CSS from './CSS.svelte';
	import JavaScript from './JavaScript.svelte';
</script>

To animate Zdog shapes you need JavaScript, there's no escaping it. You can't run away from the language, but if you don't mind being cheeky, you can have CSS do the heavy lifting. The trick is wickedly simple, but is best understood in practice.

Lock on the following 2D graphic.

<Center element="figure" maxInlineSize="20rem">
	{@html svg['target']}
</Center>

CSS is more than able to update the elements in a larger `<svg>`. You can even set up two distinct animations, working in tandem to affect the graphic in different manners.

```css
#target {
	animation: rotate 3s infinite, translate 9s infinite;
}
```

The excellent news is that CSS supports individual transform properties. With one animation you can rock the graphic back and forth.

```css
@keyframes rotate {
	0%,
	50%,
	100% {
		rotate: 0deg;
	}

	25% {
		rotate: -20deg;
	}

	75% {
		rotate: 20deg;
	}
}
```

With the other you can move the figure up and down.

```css
@keyframes rotate {
	0%,
	50%,
	100% {
		translate: 0px 0px;
	}

	25% {
		translate: 0px -20px;
	}

	75% {
		translate: 0px 20px;
	}
}
```

There are several keyframes, several stopping points which make the default motion feel rather unnatural. Luckily, you are able to change the pace with an easing function. You can tinker with the value in the keyframes as well, but in my brief exploration, I found a sound combination with two of the supported keywords: `ease-out` and `ease-in`.

Ease-out in the resting position.

```css
0%,
50%,
100% {
	rotate: 0deg;
	animation-timing-function: ease-out;
}
```

Ease-in in the keyframes which follow. The approach is similar in both animations, and the result is quite appealing.

<Center maxInlineSize="350px">
	<CSS />
</Center>

The change feels almost natural as the character levitates in smooth stops. And above all, impressive considering how much CSS handles for you. Which begs the question: why can't you do the same to animate Zdog shapes?

## JavaScript

In Zdog you work with an illustration.

```js
const element = document.querySelector('#illustration');
const illustration = new Zdog.Illustration({
	element
});
```

As you add objects with different classes, `Rect`angles, `Box`es and the like, the library populates the chosen element with the pseudo-3D graphic. All you need is one final instruction, the `updateRenderGraph` method.

```js
illustration.updateRenderGraph();
```

When you want to update the illustration, you need to do so yourself. With JavaScript. You can rotate the scene on one of the available axes.

```js
illustration.rotate.z = 1.74;
```

But every time you do that you need not to forget the final instruction.

```js
illustration.rotate.z = 1.74;
illustration.updateRenderGraph();
```

One way you have to animate the change over time is with `requestAnimationFrame`. The idea is to call a function over and over.

```js
const animate = () => {
	// ...
	requestAnimationFrame(animate);
};

animate();
```

It is in the looping function that you then handle the change **and** you update the illustration.

```js
const animate = () => {
	// ...rotate & translate

	illustration.updateRenderGraph();
	requestAnimationFrame(animate);
};
```

So assume you take the time to recreate the 2D drawing with Zdog classes. You need to update the illustration in two ways, in angle and in vertical offset. But with what values? You can keep a counter variable and update the value in the animating function. And `ease-in`, `ease-out` are easing functions. They receive an input and return a value. This option certainly opens a way, but truth being told, the logic goes over my head.

Modeling a variable to find the right angle, and then going through the process once more for the y coordinate looks very challenging. Especially considering just how beautiful the CSS version was. Why can't you just follow the example? Why not indeed?

Why don't you run the CSS animation, as smoothly as only CSS knows how.

And why not just take the values directly from the graphic?

```js
const target = document.querySelector('#target');

const animate = () => {
	const { translate, rotate } = getComputedStyle(target);

	// ...
};
```

With `getComputedStyle` style you find the angle and the position. And these change per the keyframe animations. No need to re-model the change yourself.

You need a couple extra steps to find the appropriate numbers, but that's it.

Immediately, `getComputedStyle` returns a string with a unit â€” _"-23.253deg"_ and _"-10px"_, but you want a proper number instead. I managed the feat with a couple of regular expressions, so you can certainly figure out a better way on your own.

```js
const y = parseFloat(translate.match(/([-\d.]+)px$/)[0]);
const degrees = parseFloat(rotate.match(/^([-\d.]+)deg$/)[0]);
```

Finally, you need values fitting the scene, fitting the scope of the illustration. For the angle, for instance, Zdog reasons in radians. Nothing that a quick conversion won't be able to fix.

<!-- prettier-ignore -->
```js
illustration.rotate.z = degrees / 180 * Math.PI;
```

For the offset, the value might push the graphic too little, or too much. You can multiply the measure with an arbitrary weight.

```js
illustration.translate.y = y * 0.5;
```

Or again consider a more complex `map` function, mapping the offset to an appropriate range.

```js
illustration.translate.y = map(y, -offset, offset, -2.5, 2.5);
```

I'll let you write the logic of the function as homework. Personally, I'm just ecstatic to see the result in action. An effective mirror shot.

<JavaScript />

The web platform is amazing! You can now animate Zdog shapes with CSS.

Should you?

As a proof-of-concept, the solution is brilliant in its simplicity. As a prototyping tool, it is also an excellent way to debug even complex changes. If you are more serious about animations, however, you need to be wary. The browser needs to update the page with CSS, extract the data from the window and re-inject the values in the illustration. `requestAnimationFrame` helps you out, for instance pausing the update when you switch your attention to a different tab, a different application, but the operation is computationally intensive. Test the code, and maybe do rely on JavaScript, on animation libraries to take care of the rest.
